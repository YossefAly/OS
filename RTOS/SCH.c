/*
 * SCH.c
 *
 *  Created on: Jun 22, 2024
 *      Author: ALY
 */




#include "SCH.h"
#include "RTOSFIFO.h"
struct {
	TCB_RTOS* OSTasks[Tasks]; //Sch. Table
	unsigned int _S_MSP_Task ;
	unsigned int _E_MSP_Task ;
	unsigned int PSP_Task_Locator ;
	unsigned int NoOfActiveTasks ;
	TCB_RTOS* CurrentTask ;
	TCB_RTOS* NextTask ;
	enum{
		OSsuspend,
		OsRunning
	}OSmodeID;
}OS_Control;

typedef enum {
	SVC_Activatetask,
	SVC_terminateTask,
	SVC_TaskWaitingTime,
	SVC_AquireMutex,
	SVC_ReleaseMutex
}SVC_ID;

Queue_t Ready_QUEUE ;

TCB_RTOS* Ready_QUEUE_Queue[Tasks] ;
TCB_RTOS MYRTOS_idleTask ;

//This is an implementation of the PendSV_Handler function in an operating system for ARM Cortex-M microcontrollers.
//The purpose of the handler is to perform a context switch between two tasks, saving the context of the current task and restoring the context of the next task.
//The context of a task includes the contents of the processor's registers, and the task's program stack pointer (PSP).
//The handler uses inline assembly code to access the values stored in the register file and manipulate the PSP.
//The OS_Control structure holds information about the current and next tasks to be executed,
//and the OS_GET_PSP and OS_SET_PSP macros are used to read and write the PSP register, respectively.
//The handler is defined with the "naked" attribute, which means that the function does not have a standard prologue or epilogue generated by the compiler,
//		allowing for full control over the handling of the processor's stack.

__attribute ((naked)) void PendSV_Handler()
{
	//====================================
	//Save the Context of the Current Task
	//====================================
	//Get the Current Task "Current PSP from CPU register" as CPU Push XPSR,.....,R0
	GET_OS_PSP(OS_Control.CurrentTask->_C_PSP);

	//using this _C_PSP (Pointer) tp store (R4 to R11)
	OS_Control.CurrentTask->_C_PSP-- ;
	__asm volatile("mov %0,r4 " : "=r" (*(OS_Control.CurrentTask->_C_PSP))  );
	OS_Control.CurrentTask->_C_PSP-- ;
	__asm volatile("mov %0,r5 " : "=r" (*(OS_Control.CurrentTask->_C_PSP))  );
	OS_Control.CurrentTask->_C_PSP-- ;
	__asm volatile("mov %0,r6 " : "=r" (*(OS_Control.CurrentTask->_C_PSP))  );
	OS_Control.CurrentTask->_C_PSP-- ;
	__asm volatile("mov %0,r7 " : "=r" (*(OS_Control.CurrentTask->_C_PSP))  );
	OS_Control.CurrentTask->_C_PSP-- ;
	__asm volatile("mov %0,r8 " : "=r" (*(OS_Control.CurrentTask->_C_PSP))  );
	OS_Control.CurrentTask->_C_PSP-- ;
	__asm volatile("mov %0,r9 " : "=r" (*(OS_Control.CurrentTask->_C_PSP))  );
	OS_Control.CurrentTask->_C_PSP-- ;
	__asm volatile("mov %0,r10 " : "=r" (*(OS_Control.CurrentTask->_C_PSP))  );
	OS_Control.CurrentTask->_C_PSP-- ;
	__asm volatile("mov %0,r11 " : "=r" (*(OS_Control.CurrentTask->_C_PSP))  );

	//save the current Value of PSP
	//already saved in _C_PSP



	//====================================
	//Restore the Context of the Next Task
	//====================================
	if (OS_Control.NextTask != NULL){
	OS_Control.CurrentTask = OS_Control.NextTask ;
	OS_Control.NextTask = NULL ;
	}

	__asm volatile("mov r11,%0 " : : "r" (*(OS_Control.CurrentTask->_C_PSP))  );
	OS_Control.CurrentTask->_C_PSP++ ;
	__asm volatile("mov r10,%0 " : : "r" (*(OS_Control.CurrentTask->_C_PSP))  );
	OS_Control.CurrentTask->_C_PSP++ ;
	__asm volatile("mov r9,%0 " : : "r" (*(OS_Control.CurrentTask->_C_PSP))  );
	OS_Control.CurrentTask->_C_PSP++ ;
	__asm volatile("mov r8,%0 " : : "r" (*(OS_Control.CurrentTask->_C_PSP))  );
	OS_Control.CurrentTask->_C_PSP++ ;
	__asm volatile("mov r7,%0 " : : "r" (*(OS_Control.CurrentTask->_C_PSP))  );
	OS_Control.CurrentTask->_C_PSP++ ;
	__asm volatile("mov r6,%0 " : : "r" (*(OS_Control.CurrentTask->_C_PSP))  );
	OS_Control.CurrentTask->_C_PSP++ ;
	__asm volatile("mov r5,%0 " : : "r" (*(OS_Control.CurrentTask->_C_PSP))  );
	OS_Control.CurrentTask->_C_PSP++ ;
	__asm volatile("mov r4,%0 " : : "r" (*(OS_Control.CurrentTask->_C_PSP))  );
	OS_Control.CurrentTask->_C_PSP++ ;

	//update PSP and exit
	SET_OS_PSP(OS_Control.CurrentTask->_C_PSP);
	__asm volatile("BX LR");

}



unsigned char IdleTaskLed ;
void MYRTOS_IdleTask()
{

	//		The "wfi" (Wait For Interrupt) instruction is used to put the processor into a low-power state until an interrupt is received. An exception is a type of interrupt, but it is not the same as the interrupt that "wfi" is waiting for. Exceptions are typically caused by events such as illegal instruction execution, divide-by-zero, or memory access violation, and are typically handled by the processor's exception handler.
	//
	//		"wfi" instruction only waits for external interrupts which are generated by peripherals or external events and not the exceptional interrupts which are generated by the CPU itself.
	//
	//		In general, when you want to wait for any type of interrupt, you can use the "wfi" instruction, but if you want to wait for a specific event, you would use the "wfe" instruction, as it allows you to wait for a specific event, rather than any interrupt.
	//
	while(1)
	{
		IdleTaskLed ^= 1 ;
 		__asm("wfe");
	}

}








void MYRTOS_Create_MainStack()
{
	OS_Control._S_MSP_Task = &_estack;
	OS_Control._E_MSP_Task = OS_Control._S_MSP_Task - MainStackSize;
	//Aligned 8 Bytes spaces between Main Task and PSP tasks
	OS_Control.PSP_Task_Locator = (OS_Control._E_MSP_Task - 8);

	//if (_E_MSP_Task <&_eheap) Error:excedded the availble stack size
}

RTOS_Error_ID RTOS_init()
{
	RTOS_Error_ID error = success ;

	//Update OS Mode (OSsuspend)
	OS_Control.OSmodeID = OSsuspend ;

	//Specify the MAIN Stack for OS
	MYRTOS_Create_MainStack();

	//Create OS Ready Queue
	if (Queue_init(&Ready_QUEUE, Ready_QUEUE_Queue, Tasks) !=FIFO_NO_ERROR)
	{
		error += FIFO_NO_ERROR ;
	}

	//Configure IDLE TASK
	strcpy (MYRTOS_idleTask.TaskName, "idleTask");
	MYRTOS_idleTask.Priority = 255 ;
	MYRTOS_idleTask.p_TaskEntry = MYRTOS_IdleTask ;
	MYRTOS_idleTask.Stack_Size = 300 ;

	error += RTOS_Create_Task(&MYRTOS_idleTask);

	return error ;

}


void MyRTOS_Create_TaskStack(TCB_RTOS* Task)
{
	/*Task Frame
	 * ======
	 * XPSR
	 * PC (Next Task Instruction which should be Run)
	 * LR (return register which is saved in CPU while TASk1 running before TaskSwitching)
	 * r12
	 * r4
	 * r3
	 * r2
	 * r1
	 * r0
	 *====
	 *r5, r6 , r7 ,r8 ,r9, r10,r11 (Saved/Restore)Manual
	 */
	Task->_C_PSP = Task->_S_PSP_TASK ;

	Task->_C_PSP-- ;
	*(Task->_C_PSP) = 0x01000000;         //DUMMY_XPSR should T =1 to avoid BUS fault;//0x01000000

	Task->_C_PSP-- ;
	*(Task->_C_PSP) = (unsigned int)Task->p_TaskEntry ; //PC

	Task->_C_PSP-- ; //LR = 0xFFFFFFFD (EXC_RETURN)Return to thread with PSP
	*(Task->_C_PSP)  = 0xFFFFFFFD ;

	for (int  j=0 ; j< 13 ; j++ )
	{
		Task->_C_PSP-- ;
		*(Task->_C_PSP)  = 0 ;

	}



}
RTOS_Error_ID RTOS_Create_Task(TCB_RTOS* Task)
{
	RTOS_Error_ID error = success ;

	//Create Its OWN PSP stack
	//Check task stack size exceeded the PSP stack
	Task->_S_PSP_TASK = OS_Control.PSP_Task_Locator;
	Task->_E_PSP_TASK = Task->_S_PSP_TASK - Task->Stack_Size ;

	//	-				-
	//	- _S_PSP_TASK	-
	//	-	Task Stack	-
	//	- _E_PSP_TASK	-
	//	-				-
	//	- _eheap		-
	//	-				-
	//

	//Aligned 8 Bytes spaces between Task PSP and other
	OS_Control.PSP_Task_Locator = (Task->_E_PSP_TASK - 8);

	//Initialize PSP Task Stack
	MyRTOS_Create_TaskStack( Task);

	//update sch Table
	OS_Control.OSTasks[OS_Control.NoOfActiveTasks]= Task ;
	OS_Control.NoOfActiveTasks++ ;


	//Task State Update -> Suspend
	Task->TaskState = Suspended ;

	return error ;

}

//Handler
void bubbleSort()
{
	unsigned int i, j , n;
	TCB_RTOS* temp ;
	n = OS_Control.NoOfActiveTasks ;
	for (i = 0; i < n - 1; i++)

		// Last i elements are already in place
		for (j = 0; j < n - i - 1; j++)
			if (OS_Control.OSTasks[j]->Priority > OS_Control.OSTasks[j + 1]->Priority)
			{
				temp = OS_Control.OSTasks[j] ;
				OS_Control.OSTasks[j] = OS_Control.OSTasks[j + 1 ] ;
				OS_Control.OSTasks[j + 1] = temp ;
			}

}
//Handler
void MyRTOS_Update_Sch()
{
	TCB_RTOS* temp =NULL ;
	TCB_RTOS* Ptask ;
	TCB_RTOS* PnextTask ;
	int i = 0 ;

	//1- bubble sort SchTable OS_Control-> OSTASKS[Tasks] (Priority high then low)
	bubbleSort();
	//2- free Ready Queue
	while(Queue_dequeue(&Ready_QUEUE, &temp /* pointer to pointer */)!=FIFO_EMPTY);

	//3- update ready queue

	while(i< OS_Control.NoOfActiveTasks)
	{
		Ptask = OS_Control.OSTasks[i] ;
		PnextTask = OS_Control.OSTasks[i+1] ;
		if (Ptask->TaskState != Suspended)
		{
			//in case we reached to the end of avaliable OSTASKS
			if (PnextTask->TaskState == Suspended)
			{
				Queue_enqueue(&Ready_QUEUE, Ptask);
				Ptask->TaskState = Ready ;
				break ;
			}
			//	if the Ptask Priority > nexttask then (lowest number is meaning higher Priority)
			if (Ptask->Priority < PnextTask->Priority )
			{
				Queue_enqueue(&Ready_QUEUE, Ptask);
				Ptask->TaskState = Ready ;
				break ;
			}else if (Ptask->Priority == PnextTask->Priority)
			{
				//	if the Ptask Priority == nexttask then
				//		push Ptask to ready state
				//	And make the ptask = nexttask  and nexttask++
				Queue_enqueue(&Ready_QUEUE, Ptask);
				Ptask->TaskState = Ready ;
			}else if (Ptask->Priority > PnextTask->Priority)
			{
				//not allowed to happen as we already reordered it by bubble sort
				break ;
			}
		}


		i++ ;
	}

}
//It checks if the ready queue (Ready_QUEUE) is empty and the current task (OS_Control.CurrentTask) is not suspended.
//		If so, the current task is set to the running state and added back to the ready queue using the Queue_enqueue function to implement the round-robin scheduling algorithm.
//
//
//Otherwise, the next task is dequeued from the ready queue using the Queue_dequeue function and set to the running state.
//		If the current task has the same Priority as the next task and is not suspended, it is added back to the ready queue and its state is set to ready.
//		The selected next task is stored in OS_Control.NextTask.
//Handler Mode
void Decide_whatNext()
{
	//if Ready Queue is empty && OS_Control->currentTask != suspend
	if (Ready_QUEUE.elements == 0 && OS_Control.CurrentTask->TaskState != Suspended) //Queue_EMPTY
	{
		OS_Control.CurrentTask->TaskState = Running ;
		//add the current task again(round robin)
		Queue_enqueue(&Ready_QUEUE, OS_Control.CurrentTask);
		OS_Control.NextTask = OS_Control.CurrentTask ;
	}else
	{
		Queue_dequeue(&Ready_QUEUE, &OS_Control.NextTask);
		OS_Control.NextTask->TaskState = Running ;
		//update Ready queue (to keep round robin Algo. happen)
		if ((OS_Control.CurrentTask->Priority == OS_Control.NextTask->Priority )&&(OS_Control.CurrentTask->TaskState != Suspended))
		{
			Queue_enqueue(&Ready_QUEUE, OS_Control.CurrentTask);
			OS_Control.CurrentTask->TaskState = Ready ;
		}
	}
}

//Handler Mode
void OS_SVC(int* Stack_Frame)
{
	//r0,r1,r2,r3,r12,LR,return address (PC) and XPSR
	unsigned char SVC_number ;
	SVC_number = *((unsigned char*)(((unsigned char*)Stack_Frame[6])-2)) ;

	switch (SVC_number)
	{
	case SVC_Activatetask:
	case SVC_terminateTask:
		//Update Sch Table, Ready Queue
		MyRTOS_Update_Sch();
		//OS is in Running State
		if (OS_Control.OSmodeID == OsRunning)
		{
			if (strcmp(OS_Control.CurrentTask->TaskName,"idleTask") != 0)
			{
				//Decide what Next
				Decide_whatNext();

				//trigger OS_pendSV (Switch Context/Restore)
				trigger_OS_PendSV();
			}
		}

		break;
	case SVC_TaskWaitingTime:
		MyRTOS_Update_Sch();


		break;
	}


}

//Thread Mode
void MYRTOS_OS_SVC_Set(SVC_ID ID)
{
	switch (ID)
	{
	case SVC_Activatetask:
		__asm("svc #0x00");
		break;
	case SVC_terminateTask:
		__asm("svc #0x01");
		break;
	case SVC_TaskWaitingTime:
		__asm("svc #0x02");
		break;
	case SVC_AquireMutex:
		__asm("svc #0x03");  //Assignment Task
		break;
	case SVC_ReleaseMutex:
		__asm("svc #0x04"); //Assignment Task
		break;
	}
}

RTOS_Error_ID RTOS_Activate_Task (TCB_RTOS* Task)
{
	Task->TaskState = Waiting ;
	MYRTOS_OS_SVC_Set(SVC_Activatetask);
}
RTOS_Error_ID RTOS_Terminate_Task (TCB_RTOS* Task)
{
	Task->TaskState = Suspended ;
	MYRTOS_OS_SVC_Set(SVC_terminateTask);
}

RTOS_Error_ID RTOS_Task_Wait(unsigned int TICKS,TCB_RTOS* Task)
{
	Task->TimeWait.Blocking = enable ;
	Task->TimeWait.TimeTicks = TICKS ;
	// Task Should be blocked
	Task->TaskState = Suspended ;
	//to be suspended immediately
	MYRTOS_OS_SVC_Set(SVC_terminateTask);

}

void RTOS_Task_Update_Wtime(){
	for (int i =0; i < OS_Control.NoOfActiveTasks ; i++  )
		{
			if (OS_Control.OSTasks[i]->TaskState == Suspended) //it is blocking until meet the time line
			{
				if (OS_Control.OSTasks[i]->TimeWait.Blocking == enable)
				{
					OS_Control.OSTasks[i]->TimeWait.TimeTicks-- ;
					if (OS_Control.OSTasks[i]->TimeWait.TimeTicks == 1)
					{
						OS_Control.OSTasks[i]->TimeWait.Blocking = disable ;
						OS_Control.OSTasks[i]->TaskState = Waiting ;
						MYRTOS_OS_SVC_Set(SVC_TaskWaitingTime);
					}
				}
			}
		}
}

RTOS_Error_ID RTOS_Acquire_Mutex(TCB_RTOS* Task,Mutex_t* Mutex){

		if(Mutex->CurrentTUser == NULL){
			Mutex->CurrentTUser = Task;
		}
		else{
			if(Mutex->CurrentTUser == Task){
				return Error;
			}
			if(Mutex->NextTUser == NULL){
				Mutex->NextTUser = Task;

				Task->TaskState = Suspended ;

				MYRTOS_OS_SVC_Set(SVC_terminateTask);
			}
			else{
				return Error;
			}
		}
		return success;
}
RTOS_Error_ID RTOS_Release_Mutex(Mutex_t* Mutex){

	if(Mutex->CurrentTUser == NULL){
		return Error;
	}
	else {
		if(Mutex->NextTUser == NULL){
			Mutex->CurrentTUser = NULL;
			return success;
		}
		else{
			Mutex->NextTUser->TaskState = Waiting;
			Mutex->CurrentTUser = Mutex->NextTUser;
			 Mutex->NextTUser = NULL;
			 MYRTOS_OS_SVC_Set(SVC_Activatetask);
			 return success;
		}
	}


}


RTOS_Error_ID RTOS_Start()
{
	OS_Control.OSmodeID = OsRunning ;
	//Set Default "Current Task =Idle Task"
	OS_Control.CurrentTask = &MYRTOS_idleTask ;
	//Activate IDLE Task
	RTOS_Activate_Task(&MYRTOS_idleTask);
	//Start Ticker
	Start_Ticker(); // 1ms

	SET_OS_PSP(OS_Control.CurrentTask->_C_PSP);
	//Switch Thread Mode SP from MSP to PSP
	SET_MSP_PSP;
	SWITCH_CPU_ACCESS_unpriveleged;
	MYRTOS_idleTask.p_TaskEntry();
}


















































